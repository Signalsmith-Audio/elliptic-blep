#ifndef SIGNALSMITH_ELLIPTIC_BLEP_H
#define SIGNALSMITH_ELLIPTIC_BLEP_H

#include <array>
#include <complex>

#ifndef M_PI
#	define M_PI 3.14159265358979323846
#endif

namespace signalsmith { namespace blep {

// Generated by design.py
// While redesigning the filter, replace with: #include "design/out/coeffs.h"
template<typename Sample>
struct EllipticBlepCoeffs {
	static constexpr size_t maxIntegrals = 3;
	static constexpr size_t complexCount = 6;
	std::array<std::complex<Sample>, complexCount> complexPoles{{
		{Sample(-9.99999999999998), Sample(17.320508075688775)},
		{Sample(-5726.939260714514), Sample(8080.5942176265635)},
		{Sample(-3893.552155112021), Sample(14063.948602720604)},
		{Sample(-2216.2312688714273), Sample(17616.634325150433)},
		{Sample(-1068.0936298180827), Sample(19431.27307638297)},
		{Sample(-311.84925586421656), Sample(20172.43872543252)}
	}};
	std::array<std::complex<Sample>, complexCount> complexCoeffs{{
		{Sample(-20.13049810496102), Sample(-11.47115192765502)},
		{Sample(-16664.47608749145), Sample(-7465.413173434912)},
		{Sample(7433.255028690656), Sample(9451.07405144271)},
		{Sample(-534.2195875020672), Sample(-6367.554653710909)},
		{Sample(-1517.6972854656349), Sample(2215.42626824697)},
		{Sample(688.7621296146389), Sample(-214.96380542910123)}
	}};
	static constexpr int realCount = 2;
	std::array<Sample, realCount> realPoles{{
		Sample(-20.00000000000003),
		Sample(-6592.667785686009)
	}};
	std::array<Sample, realCount> realCoeffs{{
		Sample(-20.130941147991493),
		Sample(10640.55702611266)
	}};
};

template<class Sample>
struct EllipticBlep {
	using Complex = std::complex<Sample>;
	using Coeffs = EllipticBlepCoeffs<Sample>;
	static constexpr size_t maxBlepOrder = Coeffs::maxIntegrals;

	EllipticBlep(Sample srate, size_t partialStepCount=128) : partialStepCount(partialStepCount) {
		Coeffs sCoeffs; // S-plane (continuous time) filter
		Sample hzToAngular = (2*M_PI)/srate;

		// Allocate the lookup table
		partialStepPoles.resize(partialStepCount + 1);

		blepCoeffs.resize(maxBlepOrder + 1);
		auto addPole = [&](size_t index, Complex pole, Complex coeff){
			coeffs[index] = coeff*hzToAngular;
			
			// Set up partial powers of the pole (so we can move forward/back by fractional samples)
			for (size_t s = 0; s <= partialStepCount; ++s) {
				Sample partial = Sample(s)/partialStepCount;
				partialStepPoles[s][index] = std::exp(partial*pole*hzToAngular);
			}
		
			// Set up
			Complex blepCoeff = 1;
			for (size_t o = 0; o <= maxBlepOrder; ++o) {
				blepCoeffs[o][index] = blepCoeff;
				blepCoeff /= pole*hzToAngular; // factor from integrating
			}
		};
		// For now, just cast real poles to complex ones
		for (size_t i = 0; i < Coeffs::realCount; ++i) {
			addPole(i, sCoeffs.realPoles[i], sCoeffs.realCoeffs[i]);
		}
		for (size_t i = 0; i < Coeffs::complexCount; ++i) {
			addPole(i + Coeffs::realCount, sCoeffs.complexPoles[i], sCoeffs.complexCoeffs[i]);
		}
		reset();
	}
	
	void reset() {
		for (auto &s : state) s = 0;
	}

	Sample get() const {
		Sample sum = 0;
		for (size_t i = 0; i < count; ++i) {
			sum += (state[i]*coeffs[i]).real();
		}
		return sum;
	}
	
	void add(Sample amount, size_t blepOrder) {
		if (blepOrder > maxBlepOrder) return;
		auto &bc = blepCoeffs[blepOrder];
		for (size_t i = 0; i < count; ++i) {
			state[i] += amount*bc[i];
		}
	}
	
	void add(Sample amount, size_t blepOrder, Sample samplesInPast) {
		if (blepOrder > maxBlepOrder) return;
		
		auto &bc = blepCoeffs[blepOrder];

		Sample tableIndex = samplesInPast*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);

		Array pulse;
		// move the pulse along in time, the same way as state progresses in .step()
		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];
		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] += bc[i]*lerpPole*amount;
		}
	}

	void step() {
		Sample sum = 0;
		const auto &poles = partialStepPoles.back();
		for (size_t i = 0; i < count; ++i) {
			sum += (state[i]*coeffs[i]).real();
			state[i] *= poles[i];
		}
	}

	void step(Sample samples) {
		Sample tableIndex = samples*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);
		while (intIndex >= partialStepCount) {
			step();
			intIndex -= partialStepCount;
		}

		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];

		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] *= lerpPole;
		}
	}

private:
	// For now, just treat the real poles as complex ones
	static constexpr size_t count = Coeffs::complexCount + Coeffs::realCount;

	using Array = std::array<Complex, count>;
	Array coeffs, state;
	std::vector<Array> blepCoeffs;
	
	// Lookup table for std::pow(pole, fractional)
	size_t partialStepCount;
	std::vector<Array> partialStepPoles;
};

}} // namespace

#endif // include guard
