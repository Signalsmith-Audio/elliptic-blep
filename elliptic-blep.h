#ifndef SIGNALSMITH_ELLIPTIC_BLEP_H
#define SIGNALSMITH_ELLIPTIC_BLEP_H

#include <array>
#include <complex>

#ifndef M_PI
#	define M_PI 3.14159265358979323846
#endif

namespace signalsmith { namespace blep {

// Generated by design.py
// While redesigning the filter, replace with: #include "design/out/coeffs.h"
template<typename Sample>
struct EllipticBlepCoeffs {
	static constexpr size_t maxIntegrals = 3;
	static constexpr size_t complexCount = 6;
	static constexpr int realCount = 2;
	std::array<std::complex<Sample>, complexCount> complexPoles{{
		{Sample(-9.999999999999968), Sample(17.320508075688757)},
		{Sample(-5562.019693104996), Sample(7721.557745942449)},
		{Sample(-3936.754373279431), Sample(13650.191094084097)},
		{Sample(-2348.1627071584026), Sample(17360.269257396852)},
		{Sample(-1177.6059328793112), Sample(19350.807275259638)},
		{Sample(-351.8405852427604), Sample(20192.24393379015)}
	}};
	std::array<Sample, realCount> realPoles{{
		Sample(-20.000000000000025),
		Sample(-6298.035731484052)
	}};
	// Coeffs for direct bandlimited synthesis of a polynomial-segment waveform
	std::array<std::complex<Sample>, complexCount> complexCoeffsDirect{{
		{Sample(-20.13756830149893), Sample(-11.467013478535181)},
		{Sample(-16453.812748230637), Sample(-7298.835752208561)},
		{Sample(7771.069750908201), Sample(9555.31023870685)},
		{Sample(-825.3820172192254), Sample(-6790.877301990311)},
		{Sample(-1529.6770476201002), Sample(2560.1909145592135)},
		{Sample(755.260843981231), Sample(-310.336256340709)}
	}};
	std::array<Sample, realCount> realCoeffsDirect{{
		Sample(-20.138060433528526),
		Sample(10325.52721970985)
	}};
	// Coeffs for cancelling the aliasing from discontinuities in an existing waveform
	std::array<std::complex<Sample>, complexCount> complexCoeffsBlep{{
		{Sample(-0.1375683014988951), Sample(0.0799919052573852)},
		{Sample(-16453.812748230637), Sample(-7298.835752208561)},
		{Sample(7771.069750908201), Sample(9555.31023870685)},
		{Sample(-825.3820172192254), Sample(-6790.877301990311)},
		{Sample(-1529.6770476201002), Sample(2560.1909145592135)},
		{Sample(755.260843981231), Sample(-310.336256340709)}
	}};
	std::array<Sample, realCount> realCoeffsBlep{{
		Sample(-0.13806043352856534),
		Sample(10325.52721970985)
	}};
};

template<class Sample>
struct EllipticBlep {
	using Complex = std::complex<Sample>;
	using Coeffs = EllipticBlepCoeffs<Sample>;
	static constexpr size_t maxBlepOrder = Coeffs::maxIntegrals;

	EllipticBlep(Sample srate, size_t partialStepCount=128) : EllipticBlep(true, srate, partialStepCount) {}

	EllipticBlep(bool direct, Sample srate, size_t partialStepCount=128) : partialStepCount(partialStepCount) {
		Coeffs sCoeffs; // S-plane (continuous time) filter
		Sample hzToAngular = (2*M_PI)/srate;

		// Allocate the lookup table
		partialStepPoles.resize(partialStepCount + 1);

		blepCoeffs.resize(maxBlepOrder + 1);
		auto addPole = [&](size_t index, Complex pole, Complex coeff){
			coeffs[index] = coeff*hzToAngular;
			
			// Set up partial powers of the pole (so we can move forward/back by fractional samples)
			for (size_t s = 0; s <= partialStepCount; ++s) {
				Sample partial = Sample(s)/partialStepCount;
				partialStepPoles[s][index] = std::exp(partial*pole*hzToAngular);
			}
		
			// Set up
			Complex blepCoeff = 1;
			for (size_t o = 0; o <= maxBlepOrder; ++o) {
				blepCoeffs[o][index] = blepCoeff;
				blepCoeff /= pole*hzToAngular; // factor from integrating
			}
		};
		// For now, just cast real poles to complex ones
		const auto &realCoeffs = (direct ? sCoeffs.realCoeffsDirect : sCoeffs.realCoeffsBlep);
		for (size_t i = 0; i < Coeffs::realCount; ++i) {
			addPole(i, sCoeffs.realPoles[i], realCoeffs[i]);
		}
		const auto &complexCoeffs = (direct ? sCoeffs.complexCoeffsDirect : sCoeffs.complexCoeffsBlep);
		for (size_t i = 0; i < Coeffs::complexCount; ++i) {
			addPole(i + Coeffs::realCount, sCoeffs.complexPoles[i], complexCoeffs[i]);
		}
		reset();
	}
	
	void reset() {
		for (auto &s : state) s = 0;
	}

	Sample get() const {
		Sample sum = 0;
		for (size_t i = 0; i < count; ++i) {
			sum += (state[i]*coeffs[i]).real();
		}
		return sum;
	}
	
	void add(Sample amount, size_t blepOrder) {
		if (blepOrder > maxBlepOrder) return;
		auto &bc = blepCoeffs[blepOrder];
		for (size_t i = 0; i < count; ++i) {
			state[i] += amount*bc[i];
		}
	}
	
	void add(Sample amount, size_t blepOrder, Sample samplesInPast) {
		if (blepOrder > maxBlepOrder) return;
		
		auto &bc = blepCoeffs[blepOrder];

		Sample tableIndex = samplesInPast*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);

		// move the pulse along in time, the same way as state progresses in .step()
		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];
		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] += bc[i]*lerpPole*amount;
		}
	}

	void step() {
		Sample sum = 0;
		const auto &poles = partialStepPoles.back();
		for (size_t i = 0; i < count; ++i) {
			sum += (state[i]*coeffs[i]).real();
			state[i] *= poles[i];
		}
	}

	void step(Sample samples) {
		Sample tableIndex = samples*partialStepCount;
		size_t intIndex = std::floor(tableIndex);
		Sample fracIndex = tableIndex - std::floor(tableIndex);
		while (intIndex >= partialStepCount) {
			step();
			intIndex -= partialStepCount;
		}

		auto &lowPoles = partialStepPoles[intIndex];
		auto &highPoles = partialStepPoles[intIndex + 1];

		for (size_t i = 0; i < count; ++i) {
			Complex lerpPole = lowPoles[i] + (highPoles[i] - lowPoles[i])*fracIndex;
			state[i] *= lerpPole;
		}
	}

private:
	// For now, just treat the real poles as complex ones
	static constexpr size_t count = Coeffs::complexCount + Coeffs::realCount;

	using Array = std::array<Complex, count>;
	Array coeffs, state;
	std::vector<Array> blepCoeffs;
	
	// Lookup table for std::pow(pole, fractional)
	size_t partialStepCount;
	std::vector<Array> partialStepPoles;
};

}} // namespace

#endif // include guard
